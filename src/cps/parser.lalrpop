#![allow(clippy::all)]
#![allow(unused_parens)]
use std::str::FromStr;
use crate::{cps::ast::*, syntax::span_with_offset};
use rustc_span::{BytePos, Span, SyntaxContext, Symbol};

grammar<'cx>(arena: &'cx CpsArena<'cx>);

pub Fns = Fn*;

// Macro def for comma-separated things
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Fn: FnDef<'cx> =
    <lo: @L> "fn" <name: ContIdent> "(" <args: Args> ")" "ret" <cont: ContIdent> "(" <ret: Tydent> ")" "=" <body: FuncBody> <hi: @R> =>
        FnDef { name, args, cont, ret, body, span: span_with_offset(lo, hi, BytePos(0), SyntaxContext::root()) };

Ident: Symbol = r"([a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => Symbol::intern(<>);
Local: Local = Ident;
ContIdent: Symbol = Ident;

Tydent: Tydent<'cx> = {
    <ident: Local> ":" "{" <ty: BasicType> "|" <pred: Pred> "}" => Tydent { ident, reft: arena.refts.intern(Type::Reft { ident, ty, pred }) },
    <ident: Local> ":" <reft: Type> => Tydent { ident, reft },
};

Args: &'cx Slice<Tydent<'cx>> = Comma<Tydent> => arena.tyd_args.alloc(<>);

Literal: Literal = {
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    r"[0-9]+" => Literal::Int(i128::from_str(<>).unwrap()),
};

Projection: Projection = "." <r"[0-9]+"> => usize::from_str(<>).unwrap();

Path: Path<'cx> = <ident: Local> <projs: Projection*> => Path { ident, projs: arena.projs.alloc(projs) };

Operand: Operand<'cx> = {
    Path => Operand::Path(<>),
    Literal => Operand::Lit(<>),
};

RValue: RValue<'cx> = {
    Operand => RValue::Op(<>),
    <arg1: Operand> <op: RBinOp> <arg2: Operand> => RValue::Binary(op, arg1, arg2),
};

RBinOp: RBinOp = {
    "+" => RBinOp::CheckedAdd,
    "<" => RBinOp::Lt,
    "<=" => RBinOp::Le,
    "==" => RBinOp::Eq,
    ">=" => RBinOp::Ge,
    ">" => RBinOp::Gt,
};

FuncBody: &'cx FuncBody<'cx> = {
    "let" <Local> "=" <RValue> "in" <FuncBody> => arena.bodies.intern(FuncBody::Let(<>)),
    "letcont" <ContIdent> "(" <Args> ")" "=" <FuncBody> "in" <FuncBody> => arena.bodies.intern(FuncBody::LetCont(<>)),
    "if" <Path> "then" <FuncBody> "else" <FuncBody> => arena.bodies.intern(FuncBody::Ite(<>)),
    "call" <ident: ContIdent> "(" <ls: Comma<Local>> ")" "ret" <kid: ContIdent> => arena.bodies.intern(FuncBody::Call(ident, arena.loc_args.alloc(ls), kid)),
    "jump" <ident: ContIdent> "(" <ls: Comma<Local>> ")" => arena.bodies.intern(FuncBody::Jump(ident, arena.loc_args.alloc(ls))),
    "abort" => arena.bodies.intern(FuncBody::Abort),
};

BasicType: BasicType = {
    "bool" => BasicType::Bool,
    IntTy => BasicType::Int(<>),
};

IntTy: IntTy = {
    "i8" => IntTy::I8,
    "i16" => IntTy::I16,
    "i32" => IntTy::I32,
    "i64" => IntTy::I64,
    "i128" => IntTy::I128,
    "u8" => IntTy::U8,
    "u16" => IntTy::U16,
    "u32" => IntTy::U32,
    "u64" => IntTy::U64,
    "u128" => IntTy::U128,
};

Type: &'cx Type<'cx> = {
    "fn" "(" <args: Args> ")" "->" <ret: Tydent> => arena.refts.intern(Type::Fn { args, ret }),
    "{" <ident: Local> ":" <ty: BasicType> "|" <pred: Pred> "}" => arena.refts.intern(Type::Reft { ident, ty, pred }),
    "(" <Args> ")" => arena.refts.intern(Type::Prod(<>)),
    <ty: BasicType> => arena.refts.intern(Type::Reft {
        ident: Symbol::intern("_v"),
        ty,
        pred: arena.preds.intern(Pred::Op(Operand::Lit(Literal::Bool(true))))
    }),
};

LeftAssoc<OpGroup, NextExprLevel>: &'cx Pred<'cx> = {
    <e1: LeftAssoc<OpGroup, NextExprLevel>>
    <op: OpGroup>
    <e2: NextExprLevel> =>
        arena.preds.intern(Pred::Binary(op, e1, e2)),
    NextExprLevel,
};

Pred: &'cx Pred<'cx> = {
    <e1: LeftAssoc<OpGroup1, ExprLevel2>>
    <op: OpGroup1>
    <e2: ExprLevel2> =>
        arena.preds.intern(Pred::Binary(op, e1, e2)),
    ExprLevel2 => <>,
};

ExprLevel2: &'cx Pred<'cx> = {
    <e1: ExprLevel3> <op: OpGroup2> <e2: ExprLevel3> =>
        arena.preds.intern(Pred::Binary(op, e1, e2)),
    ExprLevel3,
}

ExprLevel3: &'cx Pred<'cx> = LeftAssoc<OpGroup3, ExprLevel4>;

ExprLevel4: &'cx Pred<'cx> = {
    <op: PredUnOp> <e: ExprLevel5> => arena.preds.intern(Pred::Unary(op, e)),
    ExprLevel5,
}

ExprLevel5: &'cx Pred<'cx> = Operand => arena.preds.intern(Pred::Op(<>));

OpGroup1: PredBinOp = {
    "&&" => PredBinOp::And,
}

OpGroup2: PredBinOp = {
    "<" => PredBinOp::Lt,
    "<=" => PredBinOp::Le,
    ">" => PredBinOp::Gt,
    ">=" => PredBinOp::Ge,
    "==" => PredBinOp::Eq,
}

OpGroup3: PredBinOp = {
    "+" => PredBinOp::Add,
}

PredUnOp: PredUnOp = {
    "!" => PredUnOp::Not,
};
