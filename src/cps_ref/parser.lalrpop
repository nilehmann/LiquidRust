use std::str::FromStr;
use crate::cps_ref::ast::*;
use rustc_span::Symbol;
use crate::cps_ref::context::LiquidRustCtxt;

grammar<'lr>(cx: &'lr LiquidRustCtxt<'lr>);

pub Fn: FnDef<'lr> =
 "fn" <name: Symbol>
 "(" <heap: Heap> ";" <args: Args> ")"
 "ret" <ret: Symbol> "(" <out_heap: Heap> ";" <out_ty: OwnRef> ")"
 "=" <body: FnBody> => FnDef { <> };

FnBody: Box<FnBody<'lr>> = {
  "letcont" <name: Symbol> "(" <heap: Heap> ";" <env: Env> ";" <params: Args> ")"
    "=" <body: FnBody> "in" <rest: FnBody>
      => Box::new(FnBody::LetCont{ <> }),

  "if" "*" <discr: Place> "then" <then_branch: FnBody> "else" <else_branch: FnBody>
    => Box::new(FnBody::Ite{ <> }),

  "call" <func: Symbol> "(" <args: Comma<Local>> ")" "ret" <ret: Symbol>
    => Box::new(FnBody::Call{ <> }),

  "jump" <target: Symbol> "(" <args: Local*> ")" => Box::new(FnBody::Jump{ <> }),

  <Statement> ";" <FnBody> => Box::new(FnBody::Seq(<>)),

  "abort" => Box::new(FnBody::Abort)
}

Statement: Statement = {
  "let" <Local> "=" "new" "(" <TypeLayout> ")" => Statement::Let(<>),
  <Place> ":=" <Rvalue> => Statement::Assign(<>)
}

Rvalue: Rvalue = {
  Operand => Rvalue::Use(<>),
  <lhs: Operand> <op: BinOp> <rhs: Operand> => Rvalue::BinaryOp(op, lhs, rhs)
}

Operand: Operand = {
  "*" <Place> => Operand::Deref(<>),
  <Constant> => Operand::Constant(<>),
}

Constant: Constant = {
  "true" => Constant::Bool(true),
  "false" => Constant::Bool(false),
  r"[0-9]+" => Constant::Int(u128::from_str(<>).unwrap())
}

BasicType: BasicType = {
  "int" => BasicType::Int,
  "bool" => BasicType::Bool
}

TypeLayout: TypeLayout = {
  r"[0-9]+" => TypeLayout::Block(u32::from_str(<>).unwrap()),
  "(" <Comma<TypeLayout>> ")" => TypeLayout::Tuple(<>)
}

Place: Place = <local: Local> <projection: Projection*> => Place { <> };

Projection: u32 = "." <r"[0-9]+"> => u32::from_str(<>).unwrap();

Ty: Ty<'lr> = {
  "own" "(" <Location> ")" => cx.mk_ty(TyS::OwnRef(<>)),
  "{" <bind: Var> ":" <ty: BasicType> "|" <pred: PredLevel1> "}"
    => cx.mk_ty(TyS::Refine { bind, ty, pred }),
  "(" <Comma<Binding<Var, Ty>>> ")" => cx.mk_ty(TyS::Tuple(<>))
}

OwnRef: OwnRef= "own" "(" <Location> ")" => OwnRef(<>);

PredLevel1 = LeftAssoc<BinOpGroup1, PredLevel2>;

PredLevel2 = LeftAssoc<BinOpGroup2, PredLevel3>;

PredLevel3: Pred<'lr> = {
  Constant => cx.mk_pred(PredS::Constant(<>)),
  <var: Var> <projection: Projection*> => cx.mk_pred(PredS::Place { <> })
}

Var: Var = r"([a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => Var::intern(<>);

Args = Comma<Binding<Local, OwnRef>>;
Env = Comma<Binding<Local, OwnRef>>;
Heap = Comma<Binding<Location, Ty>>;

Symbol: Symbol = r"([a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => Symbol::intern(<>);
Local: Local = Symbol => Local(<>);
Location: Location = Symbol => Location(<>);
Binding<Name, T> = <Name> ":" <T>;

BinOpGroup1: BinOp = {
  "+" => BinOp::Add,
  "-" => BinOp::Sub
}

BinOpGroup2: BinOp = {
  "<" => BinOp::Lt,
  "<=" => BinOp::Le,
  "==" => BinOp::Eq,
  ">=" => BinOp::Ge,
  ">" => BinOp::Gt,
};

BinOp = {
  BinOpGroup1, BinOpGroup2
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

LeftAssoc<OpGroup, NextExprLevel>: Pred<'lr> = {
    <lhs: LeftAssoc<OpGroup,NextExprLevel>>
    <op: OpGroup>
    <rhs: NextExprLevel>
      => cx.mk_pred(PredS::BinaryOp(op, lhs, rhs)),
    NextExprLevel,
};